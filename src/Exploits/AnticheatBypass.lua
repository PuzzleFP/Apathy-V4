--[[
    How the anticheat works:
        - When the character is created, a request for a copy of the anticheat is sent to the server
        - A copy of the anticheat, and a GUID are returned, the checkin function of this copy of the anticheat is called every 15 seconds using the GUID

    How this mechanism is thwarted
        - The anticheat module is intercepted, and all detection functions are overwritten so that they cannot be called
        - Only the checkin function is not called

    Mechanisms in place to detect anticheat changes:
        - Layer searching 
            - Change in script strucuture

            - Change in script hash
                - Scan the script to detect changes in upvalues, constants and protos, and function names
                    - Should a mutation be indentified, it is to be evaluated at the external server whether or not to stop new instances of the exploit loading
                    - Clients will not be able to conenct when connections are disabled

        - Unathorised remote usage
            - Unathorised server invocation by the anticheat remote
                - Should this be the case, a request is to be sent to the server to shutdown all new instances from connection and a developer is to be notified

            - Unathorised remote passing anticheat detections to the server
                - The script is to be immediately terminated, and a request is to be sent to shut off the exploit

    - Inbuilt features of the anticheat bypasser allow it to adapt to new changes automatically
--]]

local HttpService = game:GetService("HttpService")

local function GetScriptHashFromServer(Script)
    return PerformInstruction("GetScriptHash", Script.Name)
end 

local function GetScriptProfileFromServer(Script)
    return PerformInstruction("GetScriptProfile", Script.Name)
end 

local function UpdateScriptProfile(Script, NewScriptProfile, ProfileChanges, NewScriptBytecodeHash)
    local ScriptContext =  {Name = Script.Name, 
                Profile = NewScriptProfile, 
                Changes = ProfileChanges, 
                Hash = NewScriptBytecodeHash}

    PerformInstruction("UpdateScriptProfile", HttpService:JSONEncode(ScriptContext))
end 

local function ScriptChanged(Script)
    local StoredScriptBytecodeHash = GetScriptHashFromServer(Script.Name)
    local CurrentScriptBytecodeHash = getscripthash(Script)

    -- No change in script bytecode, so no need to perform further checks
    if StoredScriptBytecodeHash == CurrentScriptBytecodeHash then 
        return false
    end 

    local CurrentScriptProfile = GetScriptProfileFromServer(Script.Name)
    -- Check the scripts global environment, and compare it against what is already stored
    local NewScriptProfile = ScriptProfile.BuildProfile(Script.Name)
    local ProfileChanges = ScriptProfile.CompareProfile(CurrentScriptProfile, NewScriptProfile)

    UpdateScriptProfile(Script, NewScriptProfile, ProfileChanges, CurrentScriptBytecodeHash)
end 

local function MatchScript(Script, ScriptToMatch)
    local StoredScriptBytecodeHash = GetScriptHashFromServer(ScriptToMatch)
    local CurrentScriptBytecodeHash = getscripthash(Script)

    if not StoredScriptBytecodeHash then 
        return false, string.format("There is no stored bytecode for the script: %s", ScriptToMatch)
    end 

    if StoredScriptBytecodeHash == CurrentScriptBytecodeHash then 
        return true
    end 
end 

-- Dump all detection codes, and remotes so that they can be spied on if they are somehow called
local DetectionCodes = {}
local DetectionRemotes = {}

local ReplicatedStorage = game:GetService("ReplicatedStorage")

local Client = ReplicatedStorage.Client
local Loader = Client.Loader 

-- Source of where an anticheat instance is spawned from
local FollowMouse = require(Loader.FollowMouse)

if ScriptChanged(FollowMouse) then 
    NotifyClient("Please wait for an update to release")
    error()
end 

-- Known module of where anticheat is used
local SwimController = require(Loader.SwimController)

if ScriptChanged(SwimController) then 
    NotifyClient("Please wait for an update to release")
    error()
end 

--[[
    Should an anticheat mutation be reported, and manual intervention is required, the code below is subject to change to accommodate for that
--]]

-- DETECTION VECTOR 1
-- Strip the [onCharacter] function of all protos that report detections to the server

for _, v in ipairs(debug.getprotos(SwimController.onCharacter)) do 
    if debug.info(v, "n") == "fire" then 
        --[[
            If the function is already running, force an error to prevent it from continuing execution
        --]]
        for i, Upvalue in ipairs(debug.getupvalues(v)) do 
            debug.setupvalue(v, i, nil)
        end 

        -- Make the function inaccessible by overwriting it in memory
        hookfunction(v, function() end)
    end 
end 

--[[
    If the preloaded anticheat module is already running, attempt to extract all the detection codes
    And check if it has changed, if so drastically, manual intervention will be required
--]]

-- DETECTION VECTOR 2
local LoadedModules = getloadedmodules()

for _, LoadedModule in ipairs(LoadedModules) do 
    local IsAnticheatModule = MatchScript(LoadedModule, "MainAnticheatModule")

    if not IsAnticheatModule then 
        continue 
    end 

    for _, Check in ipairs(AnticheatChecks) do 
        if debug.info(Check, "n") == "checkin" then 
            continue 
        end
        
        local CheckUpvalues = debug.getupvalues(Check)
        for CheckIndice in ipairs(CheckUpvalues) do 
            debug.setupvalue(Check, CheckIndice, nil)
        end 
    end 
end

-- DETECTION VECTOR 3
local RobloxScriptEnvironment = getrenv()

RobloxScriptEnvironment.require = function(Module) 
    local IsAnticheatModule = MatchScript(Module, "MainAnticheatModule")

    if not IsAnticheatModule then 
        return require(Module)
    end 
    
    local AnticheatModule = require(Module)
    --[[
        Extract the check-in function, and build a new custom function with only that being called
    --]]

    for i, Check in ipairs(debug.getupvalues(AnticheatModule)) do
        if debug.info(Check, "n") == "checkin" then
            continue
        end 

        -- Overwrite the detection functions so they cannot be accessed
        hookfunction(Check, function() end)
        setupvalue(AnticheatModule, i, nil)
    end 

    return AnticheatModule
end 

-- DETECTION VECTOR 4
